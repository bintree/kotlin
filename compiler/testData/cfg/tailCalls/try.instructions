== foo ==
tailRecursive fun foo() {
    try {
        return foo()
    }
    catch (e: Throwable) {
    }
}
---------------------
L0:
  0 <START>
  1 mark({ try { return foo() } catch (e: Throwable) { } })
  1 mark(try { return foo() } catch (e: Throwable) { })
  1 jmp?(L2 [onException])                                     NEXT:[v(e: Throwable), mark({ return foo() })]
  2 mark({ return foo() })
  2 mark(foo())
  2 call(foo, foo)
  2 ret(*) L1                                                  NEXT:[<END>]
- 1 jmp(L3 [afterCatches])                                     NEXT:[<END>]                                                      PREV:[]
L2 [onException]:
  2 v(e: Throwable)                                            PREV:[jmp?(L2 [onException])]
  2 w(e)
  3 mark({ })
  3 read (Unit)
  2 jmp(L3 [afterCatches])
L1:
L3 [afterCatches]:
  0 <END>                                                      NEXT:[<SINK>]                                                     PREV:[ret(*) L1, jmp(L3 [afterCatches])]
error:
  0 <ERROR>                                                    PREV:[]
sink:
  0 <SINK>                                                     PREV:[<ERROR>, <END>]
=====================
